; Object actually defines an object, so in order to make a templated
; object that can be shared we have to pass it around as a lambda

(set person_builder (fn (name :S age :I department :S ) :* 
    (dict
    
    ; note that we quote the items so they evaluate to lists

        '("name" name) ; must be (<STRING LITERAL> <ANY>)
        '("age" age)
        '("department" department))))


(set person (person_builder "John" 30 "Engineering"))

; A dict is also a lambda. Its an artificial lambda (created by core)
; that when called, uses arguments to access the captured built object
; the lambda fn for the map should just take a string as all dict keys
; should evaluate to strings.

(set target_field "name")

(person target_field) ; "John"
(person "age") ; 30
(person "department") ; "Engineering"

; Users cant define "$" identifiers so "$set" as a special sub-command
; inside the lambda environment can yield a setter function to update
; the particular instance of the object without copying the whole
; object
((person "$set") "name" "Jane")


; Outside of person, the identifier $set is not reachable as it is contained
; inside of an specific-to "person"



(set example_dict (dict)) ; should be valud 

((example_dict "$set") "name" "John")
(example_dict "name") ; "John"

((example_dict "$set") "not a person object, so some random key" "value")


(example_dict "not a person object, so some random key") ; "value"

; use an identifier to change what key is used
(set key "something_else")
((example_dict "$set") key 30)
(example_dict key) ; 30

