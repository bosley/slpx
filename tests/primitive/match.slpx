(use "bootstrap.slpx")

(putln "=== Match Tests ===")

(set test_match_string_exact (fn () :I
    (set result (match "hello"
        '("hello" (fn (x :S) :I 1))
        '("world" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_string_exact) "match: exact string match should work")

(set test_match_integer_exact (fn () :I
    (set result (match 42
        '(42 (fn (x :I) :I 1))
        '(99 (fn (x :I) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_integer_exact) "match: exact integer match should work")

(set test_match_real_exact (fn () :I
    (set result (match 3.14
        '(3.14 (fn (x :R) :I 1))
        '(2.71 (fn (x :R) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_real_exact) "match: exact real match should work")

(set test_match_zero (fn () :I
    (set result (match 0
        '(0 (fn (x :I) :I 1))
        '(1 (fn (x :I) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_zero) "match: zero should match")

(putln "Exact matching passed")

(set test_match_prefix_wildcard (fn () :I
    (set result (match "hello_world"
        '("hello*" (fn (x :S) :I 1))
        '("other" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_prefix_wildcard) "match: prefix wildcard should work")

(set test_match_suffix_wildcard (fn () :I
    (set result (match "test_file"
        '("*file" (fn (x :S) :I 1))
        '("other" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_suffix_wildcard) "match: suffix wildcard should work")

(set test_match_contains_wildcard (fn () :I
    (set result (match "hello_beautiful_world"
        '("*beautiful*" (fn (x :S) :I 1))
        '("other" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_contains_wildcard) "match: contains wildcard should work")

(set test_match_wildcard_not_match (fn () :I
    (set result (match "goodbye"
        '("hello*" (fn (x :S) :I 0))
        '("*world" (fn (x :S) :I 0))
        '("*bye" (fn (x :S) :I 1))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_wildcard_not_match) "match: wildcard should not match incorrect strings")

(set test_match_escaped_asterisk (fn () :I
    (set result (match "file*.txt"
        '("file\\*.txt" (fn (x :S) :I 1))
        '("file" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_escaped_asterisk) "match: escaped asterisk should match literal")

(putln "Wildcard matching passed")

(set test_match_first_wins (fn () :I
    (set result (match 100
        '(100 (fn (x :I) :I 1))
        '(100 (fn (x :I) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_first_wins) "match: first matching pattern should win")

(set test_match_second_pattern (fn () :I
    (set result (match 50
        '(100 (fn (x :I) :I 0))
        '(50 (fn (x :I) :I 1))
        '(25 (fn (x :I) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_second_pattern) "match: second pattern should match if first doesn't")

(set test_match_last_pattern (fn () :I
    (set result (match 10
        '(20 (fn (x :I) :I 0))
        '(30 (fn (x :I) :I 0))
        '(10 (fn (x :I) :I 1))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_last_pattern) "match: last pattern should match if others don't")

(putln "Pattern ordering passed")

(set test_match_with_variable (fn () :I
    (set myval 42)
    (set result (match myval
        '(42 (fn (x :I) :I 1))
        '(99 (fn (x :I) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_with_variable) "match: should work with variables")

(set test_match_return_string (fn () :I
    (set result (match 5
        '(5 (fn (x :I) :S "matched"))))
    (str/eq result "matched")))
(ASSERT_TRUE (test_match_return_string) "match: should return non-integer types")

(set test_match_return_value (fn () :I
    (set result (match "test"
        '("test" (fn (x :S) :S x))))
    (str/eq result "test")))
(ASSERT_TRUE (test_match_return_value) "match: function should receive matched value")

(set test_match_use_matched_value (fn () :I
    (set result (match 10
        '(10 (fn (x :I) :I (int/add x 5)))))
    (int/eq result 15)))
(ASSERT_TRUE (test_match_use_matched_value) "match: function can use matched value")

(putln "Value handling passed")

(set test_match_negative_int (fn () :I
    (set result (match (int/sub 0 5)
        '(-5 (fn (x :I) :I 1))
        '(5 (fn (x :I) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_negative_int) "match: negative integers should match")

(set test_match_empty_string (fn () :I
    (set result (match ""
        '("" (fn (x :S) :I 1))
        '("x" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_empty_string) "match: empty string should match")

(set test_match_wildcard_full_string (fn () :I
    (set result (match "anything"
        '("*" (fn (x :S) :I 1))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_wildcard_full_string) "match: single asterisk should match any string")

(set test_match_string_prefix_only (fn () :I
    (set result (match "test"
        '("test*" (fn (x :S) :I 1))
        '("testing" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_string_prefix_only) "match: prefix wildcard should match exact string")

(putln "Edge cases passed")

(set test_match_no_patterns (fn () :I
    (try
        (do
            (match 42)
            0)
        1)))
(ASSERT_TRUE (test_match_no_patterns) "match: no patterns should error")

(set test_match_single_arg (fn () :I
    (try
        (do
            (match 42
                '(42 (fn (x :I) :I 1)))
            0)
        0)))
(ASSERT_FALSE (test_match_single_arg) "match: single pattern should work")

(putln "Argument count validation passed")

(set test_match_no_match_found (fn () :I
    (try
        (do
            (match 99
                '(1 (fn (x :I) :I 1))
                '(2 (fn (x :I) :I 1))
                '(3 (fn (x :I) :I 1)))
            0)
        1)))
(ASSERT_TRUE (test_match_no_match_found) "match: no matching pattern should error")

(set test_match_type_mismatch_string_int (fn () :I
    (set result (match 42
        '("42" (fn (x :S) :I 0))
        '(42 (fn (x :I) :I 1))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_type_mismatch_string_int) "match: type mismatch should skip pattern")

(set test_match_type_mismatch_int_real (fn () :I
    (set result (match 42
        '(42.0 (fn (x :R) :I 0))
        '(42 (fn (x :I) :I 1))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_type_mismatch_int_real) "match: integer should not match real")

(putln "Match behavior validation passed")

(set test_match_pattern_not_list (fn () :I
    (try
        (do
            (match 42
                42)
            0)
        1)))
(ASSERT_TRUE (test_match_pattern_not_list) "match: non-list pattern should error")

(set test_match_pattern_wrong_size_one (fn () :I
    (try
        (do
            (match 42
                '((fn (x :I) :I 1)))
            0)
        1)))
(ASSERT_TRUE (test_match_pattern_wrong_size_one) "match: single-element pattern should error")

(set test_match_pattern_wrong_size_three (fn () :I
    (try
        (do
            (match 42
                '(42 (fn (x :I) :I 1) extra))
            0)
        1)))
(ASSERT_TRUE (test_match_pattern_wrong_size_three) "match: three-element pattern should error")

(set test_match_pattern_empty_list (fn () :I
    (try
        (do
            (match 42
                '(()))
            0)
        1)))
(ASSERT_TRUE (test_match_pattern_empty_list) "match: empty list pattern should error")

(putln "Pattern structure validation passed")

(set test_match_second_not_function (fn () :I
    (try
        (do
            (match 42
                '(42 99))
            0)
        1)))
(ASSERT_TRUE (test_match_second_not_function) "match: non-function as second element should error")

(set test_match_second_is_string (fn () :I
    (try
        (do
            (match 42
                '(42 "not a function"))
            0)
        1)))
(ASSERT_TRUE (test_match_second_is_string) "match: string as second element should error")

(set test_match_second_is_list (fn () :I
    (try
        (do
            (match 42
                '(42 (1 2 3)))
            0)
        1)))
(ASSERT_TRUE (test_match_second_is_list) "match: list as second element should error")

(putln "Function validation passed")

(set test_match_pattern_not_literal_string (fn () :I
    (set result (match "test"
        '("test" (fn (x :S) :I 1))
        '("other" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_pattern_not_literal_string) "match: string patterns should work")

(set test_match_pattern_not_literal_int (fn () :I
    (set result (match 42
        '(42 (fn (x :I) :I 1))
        '(99 (fn (x :I) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_pattern_not_literal_int) "match: integer patterns should work")

(set test_match_pattern_not_literal_real (fn () :I
    (set result (match 1.5
        '(1.5 (fn (x :R) :I 1))
        '(2.5 (fn (x :R) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_pattern_not_literal_real) "match: real patterns should work")

(putln "Pattern type validation passed")

(set test_match_complex_wildcard_combo (fn () :I
    (set result (match "prefix_middle_suffix"
        '("prefix*" (fn (x :S) :I 1))
        '("other" (fn (x :S) :I 0))))
    (int/eq result 1)))
(ASSERT_TRUE (test_match_complex_wildcard_combo) "complex: wildcard with underscores should work")

(set test_match_nested_call (fn () :I
    (set helper (fn (val :I) :I
        (match val
            '(10 (fn (x :I) :I 100))
            '(20 (fn (x :I) :I 200)))))
    (set result (helper 10))
    (int/eq result 100)))
(ASSERT_TRUE (test_match_nested_call) "complex: match in function should work")

(set test_match_chained (fn () :I
    (set first (match 5
        '(5 (fn (x :I) :I 10))))
    (set second (match first
        '(10 (fn (x :I) :I 20))))
    (int/eq second 20)))
(ASSERT_TRUE (test_match_chained) "complex: chained matches should work")

(set test_match_with_do_block (fn () :I
    (set result (match 42
        '(42 (fn (x :I) :I (do
            (set temp (int/add x 8))
            temp)))))
    (int/eq result 50)))
(ASSERT_TRUE (test_match_with_do_block) "complex: match function with do block should work")

(putln "Complex scenarios passed")

(putln "")
(putln "=================================")
(putln "ALL MATCH TESTS PASSED")
(putln "=================================")
(putln "")
(putln "Test summary:")
(putln "  - Exact matching (4 tests)")
(putln "  - Wildcard matching (5 tests)")
(putln "  - Pattern ordering (3 tests)")
(putln "  - Value handling (4 tests)")
(putln "  - Edge cases (4 tests)")
(putln "  - Argument count validation (2 tests)")
(putln "  - Match behavior validation (3 tests)")
(putln "  - Pattern structure validation (4 tests)")
(putln "  - Function validation (3 tests)")
(putln "  - Pattern type validation (3 tests)")
(putln "  - Complex scenarios (4 tests)")
(putln "")
(putln "Total: 39 test assertions covering match functionality")
(putln "Positive tests: 29 | Negative tests: 10")
(putln "")

