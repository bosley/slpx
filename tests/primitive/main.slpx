;   Primitive Tests
;   My goal here was to use the most basic level functionality offered by core.go
;   to test itself, attempting to detect errors in the first ways it might fail if
;   something were tampered with in the core that could produce an edge case.
;
;   I do this by using lambdas to produce integers by-way of a conditional on
;   raw-typed objects "0" and "1". The logic internally to yield a 1 or 0 from
;   a conditional, from within a lambda, producing a checked-for "integer" type
;   exercises go code that is sensitive to change (for obvious reasons - it impacts
;   every aspect of calling, and conditions.)
;
;   We then check values against lambdas for asserting truthy/falsy values, and
;   kill execution if our expectations are not met.
;
;   In the bootstrap file, what is mentioned above is implemented immediatly, followed by
;   a long series of similar self<->referencing checks using all commands in, and only 
;   commands from, core.go.
;
;   If bootstrap passes, we can then safely assume that the core of the language is working
;   and can then proceed to load the tests of commands added via CommandGroups which are part
;   of the main language expressions, but are logically grouped seperate from the base functions required
;   to build the language itself, and other groups of main expressions.
;
;   They are tested in the order they are needed to be used to test others, as we pollute
;   the environment with all commands in top level statements on-use. 
;   We can use functions defined in the files to test others, but most importantly,
;   we gain the trust that commands tested are commands we can rely on to actually do
;   the test checking, meaining that for instance "reflection" can rely on "numbers" 
;   to be working as is below:
;   - bosley
;

(try
    (use "bootstrap.slpx")
    (do
        (putln "Error:" $error "Failed to load bootstrap")
        (exit 1)))

(try
    (use "numbers.slpx")
    (do
        (putln "Error:" $error "Failed to load numbers")
        (exit 1)))

(try
    (use "reflection.slpx")
    (do
        (putln "Error:" $error "Failed to load reflection")
        (exit 1)))

(try
    (use "str.slpx")
    (do
        (putln "Error:" $error "Failed to load str")
        (exit 1)))

(try
    (use "list.slpx")
    (do
        (putln "Error:" $error "Failed to load list")
        (exit 1)))

(try
    (use "fs.slpx")
    (do
        (putln "Error:" $error "Failed to load fs")
        (exit 1)))

(exit 0) ; should be reached
(exit 1) ; should never be reached