(use "bootstrap.slpx")

(putln "=== Numbers Tests ===")

(set test_int_add (fn () :I
    (int/eq (int/add 5 3) 8)))
(ASSERT_TRUE (test_int_add) "int/add: 5 + 3 should equal 8")

(set test_int_add_negative (fn () :I
    (int/eq (int/add -5 3) -2)))
(ASSERT_TRUE (test_int_add_negative) "int/add: -5 + 3 should equal -2")

(set test_int_add_zero (fn () :I
    (int/eq (int/add 0 0) 0)))
(ASSERT_TRUE (test_int_add_zero) "int/add: 0 + 0 should equal 0")

(putln "int/add passed")

(set test_int_sub (fn () :I
    (int/eq (int/sub 10 3) 7)))
(ASSERT_TRUE (test_int_sub) "int/sub: 10 - 3 should equal 7")

(set test_int_sub_negative (fn () :I
    (int/eq (int/sub 3 10) -7)))
(ASSERT_TRUE (test_int_sub_negative) "int/sub: 3 - 10 should equal -7")

(set test_int_sub_zero (fn () :I
    (int/eq (int/sub 5 0) 5)))
(ASSERT_TRUE (test_int_sub_zero) "int/sub: 5 - 0 should equal 5")

(putln "int/sub passed")

(set test_int_mul (fn () :I
    (int/eq (int/mul 5 3) 15)))
(ASSERT_TRUE (test_int_mul) "int/mul: 5 * 3 should equal 15")

(set test_int_mul_negative (fn () :I
    (int/eq (int/mul -5 3) -15)))
(ASSERT_TRUE (test_int_mul_negative) "int/mul: -5 * 3 should equal -15")

(set test_int_mul_zero (fn () :I
    (int/eq (int/mul 5 0) 0)))
(ASSERT_TRUE (test_int_mul_zero) "int/mul: 5 * 0 should equal 0")

(set test_int_mul_large (fn () :I
    (int/eq (int/mul 100 100) 10000)))
(ASSERT_TRUE (test_int_mul_large) "int/mul: 100 * 100 should equal 10000")

(putln "int/mul passed")

(set test_int_div (fn () :I
    (int/eq (int/div 10 2) 5)))
(ASSERT_TRUE (test_int_div) "int/div: 10 / 2 should equal 5")

(set test_int_div_truncate (fn () :I
    (int/eq (int/div 10 3) 3)))
(ASSERT_TRUE (test_int_div_truncate) "int/div: 10 / 3 should truncate to 3")

(set test_int_div_negative (fn () :I
    (int/eq (int/div -10 3) -3)))
(ASSERT_TRUE (test_int_div_negative) "int/div: -10 / 3 should truncate to -3")

(set test_int_div_by_zero (fn () :I
    (try
        (do
            (int/div 10 0)
            0)
        1)))
(ASSERT_TRUE (test_int_div_by_zero) "int/div: division by zero should error")

(putln "int/div passed")

(set test_int_mod (fn () :I
    (int/eq (int/mod 10 3) 1)))
(ASSERT_TRUE (test_int_mod) "int/mod: 10 mod 3 should equal 1")

(set test_int_mod_exact (fn () :I
    (int/eq (int/mod 10 5) 0)))
(ASSERT_TRUE (test_int_mod_exact) "int/mod: 10 mod 5 should equal 0")

(set test_int_mod_larger (fn () :I
    (int/eq (int/mod 3 10) 3)))
(ASSERT_TRUE (test_int_mod_larger) "int/mod: 3 mod 10 should equal 3")

(set test_int_mod_by_zero (fn () :I
    (try
        (do
            (int/mod 10 0)
            0)
        1)))
(ASSERT_TRUE (test_int_mod_by_zero) "int/mod: modulo by zero should error")

(putln "int/mod passed")

(set test_int_pow_basic (fn () :I
    (int/eq (int/pow 2 3) 8)))
(ASSERT_TRUE (test_int_pow_basic) "int/pow: 2^3 should equal 8")

(set test_int_pow_zero (fn () :I
    (int/eq (int/pow 5 0) 1)))
(ASSERT_TRUE (test_int_pow_zero) "int/pow: 5^0 should equal 1")

(set test_int_pow_one (fn () :I
    (int/eq (int/pow 5 1) 5)))
(ASSERT_TRUE (test_int_pow_one) "int/pow: 5^1 should equal 5")

(set test_int_pow_large (fn () :I
    (int/eq (int/pow 2 10) 1024)))
(ASSERT_TRUE (test_int_pow_large) "int/pow: 2^10 should equal 1024")

(set test_int_pow_negative_exp (fn () :I
    (try
        (do
            (int/pow 2 -1)
            0)
        1)))
(ASSERT_TRUE (test_int_pow_negative_exp) "int/pow: negative exponent should error")

(putln "int/pow passed")

(set test_int_sum_one (fn () :I
    (int/eq (int/sum 5) 5)))
(ASSERT_TRUE (test_int_sum_one) "int/sum: single argument should return value")

(set test_int_sum_multiple (fn () :I
    (int/eq (int/sum 1 2 3 4 5) 15)))
(ASSERT_TRUE (test_int_sum_multiple) "int/sum: 1+2+3+4+5 should equal 15")

(set test_int_sum_negative (fn () :I
    (int/eq (int/sum -5 10 -3) 2)))
(ASSERT_TRUE (test_int_sum_negative) "int/sum: should handle negative numbers")

(putln "int/sum passed")

(set test_real_add (fn () :I
    (real/eq (real/add 5.5 3.2) 8.7)))
(ASSERT_TRUE (test_real_add) "real/add: 5.5 + 3.2 should equal 8.7")

(set test_real_add_negative (fn () :I
    (real/eq (real/add -5.5 3.2) -2.3)))
(ASSERT_TRUE (test_real_add_negative) "real/add: should handle negative numbers")

(set test_real_add_zero (fn () :I
    (real/eq (real/add 0.0 0.0) 0.0)))
(ASSERT_TRUE (test_real_add_zero) "real/add: 0.0 + 0.0 should equal 0.0")

(putln "real/add passed")

(set test_real_sub (fn () :I
    (real/eq (real/sub 10.5 3.2) 7.3)))
(ASSERT_TRUE (test_real_sub) "real/sub: 10.5 - 3.2 should equal 7.3")

(set test_real_sub_negative (fn () :I
    (real/lt (real/sub 3.2 10.5) 0.0)))
(ASSERT_TRUE (test_real_sub_negative) "real/sub: 3.2 - 10.5 should be negative")

(putln "real/sub passed")

(set test_real_mul (fn () :I
    (real/eq (real/mul 5.0 3.0) 15.0)))
(ASSERT_TRUE (test_real_mul) "real/mul: 5.0 * 3.0 should equal 15.0")

(set test_real_mul_negative (fn () :I
    (real/eq (real/mul -5.0 3.0) -15.0)))
(ASSERT_TRUE (test_real_mul_negative) "real/mul: should handle negative numbers")

(set test_real_mul_zero (fn () :I
    (real/eq (real/mul 5.0 0.0) 0.0)))
(ASSERT_TRUE (test_real_mul_zero) "real/mul: 5.0 * 0.0 should equal 0.0")

(putln "real/mul passed")

(set test_real_div (fn () :I
    (real/eq (real/div 10.0 2.0) 5.0)))
(ASSERT_TRUE (test_real_div) "real/div: 10.0 / 2.0 should equal 5.0")

(set test_real_div_fraction (fn () :I
    (real/gt (real/div 10.0 3.0) 3.0)))
(ASSERT_TRUE (test_real_div_fraction) "real/div: 10.0 / 3.0 should be greater than 3.0")

(set test_real_div_by_zero (fn () :I
    (try
        (do
            (real/div 10.0 0.0)
            0)
        1)))
(ASSERT_TRUE (test_real_div_by_zero) "real/div: division by zero should error")

(putln "real/div passed")

(set test_real_pow (fn () :I
    (real/eq (real/pow 2.0 3.0) 8.0)))
(ASSERT_TRUE (test_real_pow) "real/pow: 2.0^3.0 should equal 8.0")

(set test_real_pow_sqrt (fn () :I
    (real/gt (real/pow 4.0 0.5) 1.9)))
(ASSERT_TRUE (test_real_pow_sqrt) "real/pow: 4.0^0.5 should be approximately 2.0")

(set test_real_pow_negative_base (fn () :I
    (real/eq (real/pow -2.0 2.0) 4.0)))
(ASSERT_TRUE (test_real_pow_negative_base) "real/pow: (-2.0)^2.0 should equal 4.0")

(set test_real_pow_nan_error (fn () :I
    (try
        (do
            (real/pow -1.0 0.5)
            0)
        1)))
(ASSERT_TRUE (test_real_pow_nan_error) "real/pow: should error on NaN result")

(putln "real/pow passed")

(set test_real_sum_one (fn () :I
    (real/eq (real/sum 5.5) 5.5)))
(ASSERT_TRUE (test_real_sum_one) "real/sum: single argument should return value")

(set test_real_sum_multiple (fn () :I
    (real/eq (real/sum 1.5 2.5 3.5) 7.5)))
(ASSERT_TRUE (test_real_sum_multiple) "real/sum: 1.5+2.5+3.5 should equal 7.5")

(putln "real/sum passed")

(set test_int_to_real (fn () :I
    (real/eq (int/real 42) 42.0)))
(ASSERT_TRUE (test_int_to_real) "int/real: 42 should convert to 42.0")

(set test_int_to_real_negative (fn () :I
    (real/eq (int/real -10) -10.0)))
(ASSERT_TRUE (test_int_to_real_negative) "int/real: -10 should convert to -10.0")

(set test_int_to_real_zero (fn () :I
    (real/eq (int/real 0) 0.0)))
(ASSERT_TRUE (test_int_to_real_zero) "int/real: 0 should convert to 0.0")

(putln "int/real passed")

(set test_real_to_int (fn () :I
    (int/eq (real/int 42.0) 42)))
(ASSERT_TRUE (test_real_to_int) "real/int: 42.0 should convert to 42")

(set test_real_to_int_floor (fn () :I
    (int/eq (real/int 3.9) 3)))
(ASSERT_TRUE (test_real_to_int_floor) "real/int: 3.9 should floor to 3")

(set test_real_to_int_negative_floor (fn () :I
    (int/eq (real/int -3.1) -4)))
(ASSERT_TRUE (test_real_to_int_negative_floor) "real/int: -3.1 should floor to -4")

(putln "real/int passed")

(set test_int_eq_true (fn () :I
    (int/eq 10 10)))
(ASSERT_TRUE (test_int_eq_true) "int/eq: 10 == 10 should be true")

(set test_int_eq_false (fn () :I
    (int/eq (int/eq 10 20) 0)))
(ASSERT_TRUE (test_int_eq_false) "int/eq: 10 == 20 should be false")

(set test_int_eq_negative (fn () :I
    (int/eq -5 -5)))
(ASSERT_TRUE (test_int_eq_negative) "int/eq: -5 == -5 should be true")

(putln "int/eq passed")

(set test_int_gt_true (fn () :I
    (int/gt 20 10)))
(ASSERT_TRUE (test_int_gt_true) "int/gt: 20 > 10 should be true")

(set test_int_gt_false (fn () :I
    (int/eq (int/gt 10 20) 0)))
(ASSERT_TRUE (test_int_gt_false) "int/gt: 10 > 20 should be false")

(set test_int_gt_equal (fn () :I
    (int/eq (int/gt 10 10) 0)))
(ASSERT_TRUE (test_int_gt_equal) "int/gt: 10 > 10 should be false")

(putln "int/gt passed")

(set test_int_gte_true (fn () :I
    (int/gte 20 10)))
(ASSERT_TRUE (test_int_gte_true) "int/gte: 20 >= 10 should be true")

(set test_int_gte_equal (fn () :I
    (int/gte 10 10)))
(ASSERT_TRUE (test_int_gte_equal) "int/gte: 10 >= 10 should be true")

(set test_int_gte_false (fn () :I
    (int/eq (int/gte 10 20) 0)))
(ASSERT_TRUE (test_int_gte_false) "int/gte: 10 >= 20 should be false")

(putln "int/gte passed")

(set test_int_lt_true (fn () :I
    (int/lt 10 20)))
(ASSERT_TRUE (test_int_lt_true) "int/lt: 10 < 20 should be true")

(set test_int_lt_false (fn () :I
    (int/eq (int/lt 20 10) 0)))
(ASSERT_TRUE (test_int_lt_false) "int/lt: 20 < 10 should be false")

(set test_int_lt_equal (fn () :I
    (int/eq (int/lt 10 10) 0)))
(ASSERT_TRUE (test_int_lt_equal) "int/lt: 10 < 10 should be false")

(putln "int/lt passed")

(set test_int_lte_true (fn () :I
    (int/lte 10 20)))
(ASSERT_TRUE (test_int_lte_true) "int/lte: 10 <= 20 should be true")

(set test_int_lte_equal (fn () :I
    (int/lte 10 10)))
(ASSERT_TRUE (test_int_lte_equal) "int/lte: 10 <= 10 should be true")

(set test_int_lte_false (fn () :I
    (int/eq (int/lte 20 10) 0)))
(ASSERT_TRUE (test_int_lte_false) "int/lte: 20 <= 10 should be false")

(putln "int/lte passed")

(set test_real_eq_true (fn () :I
    (real/eq 3.14 3.14)))
(ASSERT_TRUE (test_real_eq_true) "real/eq: 3.14 == 3.14 should be true")

(set test_real_eq_false (fn () :I
    (int/eq (real/eq 3.14 2.71) 0)))
(ASSERT_TRUE (test_real_eq_false) "real/eq: 3.14 == 2.71 should be false")

(putln "real/eq passed")

(set test_real_gt_true (fn () :I
    (real/gt 3.14 2.71)))
(ASSERT_TRUE (test_real_gt_true) "real/gt: 3.14 > 2.71 should be true")

(set test_real_gt_false (fn () :I
    (int/eq (real/gt 2.71 3.14) 0)))
(ASSERT_TRUE (test_real_gt_false) "real/gt: 2.71 > 3.14 should be false")

(putln "real/gt passed")

(set test_real_gte_true (fn () :I
    (real/gte 3.14 2.71)))
(ASSERT_TRUE (test_real_gte_true) "real/gte: 3.14 >= 2.71 should be true")

(set test_real_gte_equal (fn () :I
    (real/gte 3.14 3.14)))
(ASSERT_TRUE (test_real_gte_equal) "real/gte: 3.14 >= 3.14 should be true")

(putln "real/gte passed")

(set test_real_lt_true (fn () :I
    (real/lt 2.71 3.14)))
(ASSERT_TRUE (test_real_lt_true) "real/lt: 2.71 < 3.14 should be true")

(set test_real_lt_false (fn () :I
    (int/eq (real/lt 3.14 2.71) 0)))
(ASSERT_TRUE (test_real_lt_false) "real/lt: 3.14 < 2.71 should be false")

(putln "real/lt passed")

(set test_real_lte_true (fn () :I
    (real/lte 2.71 3.14)))
(ASSERT_TRUE (test_real_lte_true) "real/lte: 2.71 <= 3.14 should be true")

(set test_real_lte_equal (fn () :I
    (real/lte 3.14 3.14)))
(ASSERT_TRUE (test_real_lte_equal) "real/lte: 3.14 <= 3.14 should be true")

(putln "real/lte passed")

(set test_complex_expr (fn () :I
    (int/eq
        (int/mul (int/add 5 3) (int/sub 10 2))
        64)))
(ASSERT_TRUE (test_complex_expr) "complex: (5+3)*(10-2) should equal 64")

(set test_variadic_sum_squares (fn () :I
    (int/eq
        (int/sum
            (int/pow 1 2)
            (int/pow 2 2)
            (int/pow 3 2)
            (int/pow 4 2))
        30)))
(ASSERT_TRUE (test_variadic_sum_squares) "complex: sum of squares 1^2+2^2+3^2+4^2 should equal 30")

(set test_conversion_chain (fn () :I
    (int/eq
        (real/int (real/div (real/add 10.5 5.5) (real/add 2.0 2.0)))
        4)))
(ASSERT_TRUE (test_conversion_chain) "complex: (10.5+5.5)/(2.0+2.0) should floor to 4")

(putln "Complex expressions passed")

(set test_int_sum_type_error (fn () :I
    (try
        (do
            (int/sum 1 2 "bad")
            0)
        1)))
(ASSERT_TRUE (test_int_sum_type_error) "int/sum: should reject non-integer argument")

(set test_int_sum_mixed_types (fn () :I
    (try
        (do
            (int/sum 1 2.5 3)
            0)
        1)))
(ASSERT_TRUE (test_int_sum_mixed_types) "int/sum: should reject real in integer sum")

(putln "int/sum error cases passed")

(set test_real_sum_type_error (fn () :I
    (try
        (do
            (real/sum 1.5 2.5 "bad")
            0)
        1)))
(ASSERT_TRUE (test_real_sum_type_error) "real/sum: should reject non-real argument")

(set test_real_sum_int_type (fn () :I
    (try
        (do
            (real/sum 1.5 2 3.5)
            0)
        1)))
(ASSERT_TRUE (test_real_sum_int_type) "real/sum: should reject integer in real sum")

(putln "real/sum error cases passed")

(set test_int_add_string (fn () :I
    (try
        (do
            (int/add 5 "bad")
            0)
        1)))
(ASSERT_TRUE (test_int_add_string) "int/add: should reject string argument")

(set test_int_add_real (fn () :I
    (try
        (do
            (int/add 5 3.5)
            0)
        1)))
(ASSERT_TRUE (test_int_add_real) "int/add: should reject real argument")

(set test_int_sub_wrong_type (fn () :I
    (try
        (do
            (int/sub "bad" 5)
            0)
        1)))
(ASSERT_TRUE (test_int_sub_wrong_type) "int/sub: should reject string as first arg")

(set test_int_mul_wrong_type (fn () :I
    (try
        (do
            (int/mul 5 (qu (1 2 3)))
            0)
        1)))
(ASSERT_TRUE (test_int_mul_wrong_type) "int/mul: should reject list argument")

(set test_int_div_wrong_type (fn () :I
    (try
        (do
            (int/div 10 "2")
            0)
        1)))
(ASSERT_TRUE (test_int_div_wrong_type) "int/div: should reject string argument")

(set test_int_mod_wrong_type (fn () :I
    (try
        (do
            (int/mod 10 3.5)
            0)
        1)))
(ASSERT_TRUE (test_int_mod_wrong_type) "int/mod: should reject real argument")

(set test_int_pow_wrong_type (fn () :I
    (try
        (do
            (int/pow 2 "3")
            0)
        1)))
(ASSERT_TRUE (test_int_pow_wrong_type) "int/pow: should reject string exponent")

(putln "Integer arithmetic type errors passed")

(set test_real_add_string (fn () :I
    (try
        (do
            (real/add 5.5 "bad")
            0)
        1)))
(ASSERT_TRUE (test_real_add_string) "real/add: should reject string argument")

(set test_real_add_int (fn () :I
    (try
        (do
            (real/add 5.5 3)
            0)
        1)))
(ASSERT_TRUE (test_real_add_int) "real/add: should reject integer argument")

(set test_real_sub_wrong_type (fn () :I
    (try
        (do
            (real/sub 10.5 (qu (1 2)))
            0)
        1)))
(ASSERT_TRUE (test_real_sub_wrong_type) "real/sub: should reject list argument")

(set test_real_mul_wrong_type (fn () :I
    (try
        (do
            (real/mul "bad" 3.0)
            0)
        1)))
(ASSERT_TRUE (test_real_mul_wrong_type) "real/mul: should reject string as first arg")

(set test_real_div_wrong_type (fn () :I
    (try
        (do
            (real/div 10.0 2)
            0)
        1)))
(ASSERT_TRUE (test_real_div_wrong_type) "real/div: should reject integer argument")

(set test_real_pow_wrong_type (fn () :I
    (try
        (do
            (real/pow 2.0 "3")
            0)
        1)))
(ASSERT_TRUE (test_real_pow_wrong_type) "real/pow: should reject string exponent")

(putln "Real arithmetic type errors passed")

(set test_int_real_wrong_type (fn () :I
    (try
        (do
            (int/real "42")
            0)
        1)))
(ASSERT_TRUE (test_int_real_wrong_type) "int/real: should reject string argument")

(set test_int_real_already_real (fn () :I
    (try
        (do
            (int/real 42.5)
            0)
        1)))
(ASSERT_TRUE (test_int_real_already_real) "int/real: should reject real argument")

(set test_real_int_wrong_type (fn () :I
    (try
        (do
            (real/int "42")
            0)
        1)))
(ASSERT_TRUE (test_real_int_wrong_type) "real/int: should reject string argument")

(set test_real_int_already_int (fn () :I
    (try
        (do
            (real/int 42)
            0)
        1)))
(ASSERT_TRUE (test_real_int_already_int) "real/int: should reject integer argument")

(putln "Type conversion errors passed")

(set test_int_eq_wrong_type (fn () :I
    (try
        (do
            (int/eq 10 "10")
            0)
        1)))
(ASSERT_TRUE (test_int_eq_wrong_type) "int/eq: should reject string argument")

(set test_int_eq_real_arg (fn () :I
    (try
        (do
            (int/eq 10 10.0)
            0)
        1)))
(ASSERT_TRUE (test_int_eq_real_arg) "int/eq: should reject real argument")

(set test_int_gt_wrong_type (fn () :I
    (try
        (do
            (int/gt 20 "10")
            0)
        1)))
(ASSERT_TRUE (test_int_gt_wrong_type) "int/gt: should reject string argument")

(set test_int_gte_wrong_type (fn () :I
    (try
        (do
            (int/gte 20 10.5)
            0)
        1)))
(ASSERT_TRUE (test_int_gte_wrong_type) "int/gte: should reject real argument")

(set test_int_lt_wrong_type (fn () :I
    (try
        (do
            (int/lt "10" 20)
            0)
        1)))
(ASSERT_TRUE (test_int_lt_wrong_type) "int/lt: should reject string as first arg")

(set test_int_lte_wrong_type (fn () :I
    (try
        (do
            (int/lte 10 (qu (20)))
            0)
        1)))
(ASSERT_TRUE (test_int_lte_wrong_type) "int/lte: should reject list argument")

(putln "Integer comparison type errors passed")

(set test_real_eq_wrong_type (fn () :I
    (try
        (do
            (real/eq 3.14 "3.14")
            0)
        1)))
(ASSERT_TRUE (test_real_eq_wrong_type) "real/eq: should reject string argument")

(set test_real_eq_int_arg (fn () :I
    (try
        (do
            (real/eq 3.14 3)
            0)
        1)))
(ASSERT_TRUE (test_real_eq_int_arg) "real/eq: should reject integer argument")

(set test_real_gt_wrong_type (fn () :I
    (try
        (do
            (real/gt 3.14 "2.71")
            0)
        1)))
(ASSERT_TRUE (test_real_gt_wrong_type) "real/gt: should reject string argument")

(set test_real_gte_wrong_type (fn () :I
    (try
        (do
            (real/gte 3.14 2)
            0)
        1)))
(ASSERT_TRUE (test_real_gte_wrong_type) "real/gte: should reject integer argument")

(set test_real_lt_wrong_type (fn () :I
    (try
        (do
            (real/lt "2.71" 3.14)
            0)
        1)))
(ASSERT_TRUE (test_real_lt_wrong_type) "real/lt: should reject string as first arg")

(set test_real_lte_wrong_type (fn () :I
    (try
        (do
            (real/lte 2.71 (qu (3.14)))
            0)
        1)))
(ASSERT_TRUE (test_real_lte_wrong_type) "real/lte: should reject list argument")

(putln "Real comparison type errors passed")

(set test_int_div_zero_numerator (fn () :I
    (int/eq (int/div 0 5) 0)))
(ASSERT_TRUE (test_int_div_zero_numerator) "int/div: 0 / 5 should equal 0")

(set test_int_mod_zero_numerator (fn () :I
    (int/eq (int/mod 0 5) 0)))
(ASSERT_TRUE (test_int_mod_zero_numerator) "int/mod: 0 mod 5 should equal 0")

(set test_int_pow_zero_base (fn () :I
    (int/eq (int/pow 0 5) 0)))
(ASSERT_TRUE (test_int_pow_zero_base) "int/pow: 0^5 should equal 0")

(set test_int_pow_zero_zero (fn () :I
    (int/eq (int/pow 0 0) 1)))
(ASSERT_TRUE (test_int_pow_zero_zero) "int/pow: 0^0 should equal 1")

(set test_real_div_zero_numerator (fn () :I
    (real/eq (real/div 0.0 5.0) 0.0)))
(ASSERT_TRUE (test_real_div_zero_numerator) "real/div: 0.0 / 5.0 should equal 0.0")

(putln "Edge cases with zero passed")

(set test_negative_mod (fn () :I
    (int/eq (int/mod -10 3) -1)))
(ASSERT_TRUE (test_negative_mod) "int/mod: -10 mod 3 should equal -1")

(set test_negative_both_mod (fn () :I
    (int/eq (int/mod -10 -3) -1)))
(ASSERT_TRUE (test_negative_both_mod) "int/mod: -10 mod -3 should equal -1")

(set test_negative_divisor_mod (fn () :I
    (int/eq (int/mod 10 -3) 1)))
(ASSERT_TRUE (test_negative_divisor_mod) "int/mod: 10 mod -3 should equal 1")

(set test_negative_base_pow (fn () :I
    (int/eq (int/pow -2 3) -8)))
(ASSERT_TRUE (test_negative_base_pow) "int/pow: (-2)^3 should equal -8")

(set test_negative_base_even_pow (fn () :I
    (int/eq (int/pow -2 4) 16)))
(ASSERT_TRUE (test_negative_base_even_pow) "int/pow: (-2)^4 should equal 16")

(putln "Negative number edge cases passed")

(set test_comparison_boundary (fn () :I
    (int/gt (int/add 2147483647 1) 2147483647)))
(ASSERT_TRUE (test_comparison_boundary) "large int: addition should handle overflow")

(set test_real_precision (fn () :I
    (real/gt (real/add 0.1 0.2) 0.29)))
(ASSERT_TRUE (test_real_precision) "real: 0.1 + 0.2 should be greater than 0.29")

(putln "Boundary and precision cases passed")

(set test_int_rand_in_range (fn () :I
    (set r (int/rand 1 10))
    (int/eq
        (int/eq (int/gte r 1) 1)
        (int/eq (int/lte r 10) 1))))
(ASSERT_TRUE (test_int_rand_in_range) "int/rand: result should be in range [1, 10]")

(set test_int_rand_equal_bounds (fn () :I
    (int/eq (int/rand 42 42) 42)))
(ASSERT_TRUE (test_int_rand_equal_bounds) "int/rand: equal bounds should return bound value")

(set test_int_rand_negative_range (fn () :I
    (set r (int/rand -10 -5))
    (int/eq
        (int/eq (int/gte r -10) 1)
        (int/eq (int/lte r -5) 1))))
(ASSERT_TRUE (test_int_rand_negative_range) "int/rand: should handle negative range [-10, -5]")

(set test_int_rand_across_zero (fn () :I
    (set r (int/rand -5 5))
    (int/eq
        (int/eq (int/gte r -5) 1)
        (int/eq (int/lte r 5) 1))))
(ASSERT_TRUE (test_int_rand_across_zero) "int/rand: should handle range across zero [-5, 5]")

(set test_int_rand_invalid_bounds (fn () :I
    (try
        (do
            (int/rand 10 5)
            0)
        1)))
(ASSERT_TRUE (test_int_rand_invalid_bounds) "int/rand: should error when lower > upper")

(set test_int_rand_large_range (fn () :I
    (set r (int/rand 1 1000))
    (int/eq
        (int/eq (int/gte r 1) 1)
        (int/eq (int/lte r 1000) 1))))
(ASSERT_TRUE (test_int_rand_large_range) "int/rand: should handle large range [1, 1000]")

(set test_int_rand_with_variables (fn () :I
    (set lower 42)
    (set upper 100)
    (set r (int/rand lower upper))
    (int/eq
        (int/eq (int/gte r 42) 1)
        (int/eq (int/lte r 100) 1))))
(ASSERT_TRUE (test_int_rand_with_variables) "int/rand: should work with variable bounds")

(putln "int/rand passed")

(set test_real_rand_in_range (fn () :I
    (set r (real/rand 0.0 1.0))
    (int/eq
        (int/eq (real/gte r 0.0) 1)
        (int/eq (real/lt r 1.0) 1))))
(ASSERT_TRUE (test_real_rand_in_range) "real/rand: result should be in range [0.0, 1.0)")

(set test_real_rand_equal_bounds (fn () :I
    (real/eq (real/rand 3.14 3.14) 3.14)))
(ASSERT_TRUE (test_real_rand_equal_bounds) "real/rand: equal bounds should return bound value")

(set test_real_rand_negative_range (fn () :I
    (set r (real/rand -10.5 -5.5))
    (int/eq
        (int/eq (real/gte r -10.5) 1)
        (int/eq (real/lte r -5.5) 1))))
(ASSERT_TRUE (test_real_rand_negative_range) "real/rand: should handle negative range [-10.5, -5.5]")

(set test_real_rand_across_zero (fn () :I
    (set r (real/rand -5.5 5.5))
    (int/eq
        (int/eq (real/gte r -5.5) 1)
        (int/eq (real/lte r 5.5) 1))))
(ASSERT_TRUE (test_real_rand_across_zero) "real/rand: should handle range across zero [-5.5, 5.5]")

(set test_real_rand_invalid_bounds (fn () :I
    (try
        (do
            (real/rand 10.0 5.0)
            0)
        1)))
(ASSERT_TRUE (test_real_rand_invalid_bounds) "real/rand: should error when lower > upper")

(set test_real_rand_large_range (fn () :I
    (set r (real/rand 1.0 1000.0))
    (int/eq
        (int/eq (real/gte r 1.0) 1)
        (int/eq (real/lte r 1000.0) 1))))
(ASSERT_TRUE (test_real_rand_large_range) "real/rand: should handle large range [1.0, 1000.0]")

(set test_real_rand_with_variables (fn () :I
    (set real_lower 3.33)
    (set real_upper 100.0)
    (set r (real/rand real_lower real_upper))
    (int/eq
        (int/eq (real/gte r 3.33) 1)
        (int/eq (real/lte r 100.0) 1))))
(ASSERT_TRUE (test_real_rand_with_variables) "real/rand: should work with variable bounds")

(set test_real_rand_small_range (fn () :I
    (set r (real/rand 5.0 5.01))
    (int/eq
        (int/eq (real/gte r 5.0) 1)
        (int/eq (real/lt r 5.01) 1))))
(ASSERT_TRUE (test_real_rand_small_range) "real/rand: should handle small range [5.0, 5.01)")

(putln "real/rand passed")

(set test_int_rand_wrong_type (fn () :I
    (try
        (do
            (int/rand "1" 10)
            0)
        1)))
(ASSERT_TRUE (test_int_rand_wrong_type) "int/rand: should reject string argument")

(set test_int_rand_real_arg (fn () :I
    (try
        (do
            (int/rand 1 10.5)
            0)
        1)))
(ASSERT_TRUE (test_int_rand_real_arg) "int/rand: should reject real argument")

(set test_int_rand_mixed_types (fn () :I
    (try
        (do
            (int/rand 1.5 10)
            0)
        1)))
(ASSERT_TRUE (test_int_rand_mixed_types) "int/rand: should reject mixed types")

(set test_real_rand_wrong_type (fn () :I
    (try
        (do
            (real/rand "1.0" 10.0)
            0)
        1)))
(ASSERT_TRUE (test_real_rand_wrong_type) "real/rand: should reject string argument")

(set test_real_rand_int_arg (fn () :I
    (try
        (do
            (real/rand 1 10.0)
            0)
        1)))
(ASSERT_TRUE (test_real_rand_int_arg) "real/rand: should reject integer argument")

(set test_real_rand_mixed_types (fn () :I
    (try
        (do
            (real/rand 1.0 10)
            0)
        1)))
(ASSERT_TRUE (test_real_rand_mixed_types) "real/rand: should reject mixed types")

(putln "Random number type errors passed")

(set test_real_sqrt_basic (fn () :I
    (real/eq (real/sqrt 4.0) 2.0)))
(ASSERT_TRUE (test_real_sqrt_basic) "real/sqrt: sqrt(4.0) should equal 2.0")

(set test_real_sqrt_zero (fn () :I
    (real/eq (real/sqrt 0.0) 0.0)))
(ASSERT_TRUE (test_real_sqrt_zero) "real/sqrt: sqrt(0.0) should equal 0.0")

(set test_real_sqrt_large (fn () :I
    (real/eq (real/sqrt 100.0) 10.0)))
(ASSERT_TRUE (test_real_sqrt_large) "real/sqrt: sqrt(100.0) should equal 10.0")

(set test_real_sqrt_fractional (fn () :I
    (real/gt (real/sqrt 2.0) 1.4)))
(ASSERT_TRUE (test_real_sqrt_fractional) "real/sqrt: sqrt(2.0) should be greater than 1.4")

(set test_real_sqrt_negative_error (fn () :I
    (try
        (do
            (real/sqrt -1.0)
            0)
        1)))
(ASSERT_TRUE (test_real_sqrt_negative_error) "real/sqrt: should error on negative input")

(putln "real/sqrt passed")

(set test_real_exp_zero (fn () :I
    (real/eq (real/exp 0.0) 1.0)))
(ASSERT_TRUE (test_real_exp_zero) "real/exp: exp(0) should equal 1.0")

(set test_real_exp_one (fn () :I
    (real/gt (real/exp 1.0) 2.7)))
(ASSERT_TRUE (test_real_exp_one) "real/exp: exp(1) should be greater than 2.7")

(set test_real_exp_negative (fn () :I
    (real/lt (real/exp -1.0) 0.4)))
(ASSERT_TRUE (test_real_exp_negative) "real/exp: exp(-1) should be less than 0.4")

(set test_real_exp_small (fn () :I
    (real/gt (real/exp 2.0) 7.0)))
(ASSERT_TRUE (test_real_exp_small) "real/exp: exp(2) should be greater than 7.0")

(set test_real_exp_overflow (fn () :I
    (try
        (do
            (real/exp 1000.0)
            0)
        1)))
(ASSERT_TRUE (test_real_exp_overflow) "real/exp: should error on overflow")

(putln "real/exp passed")

(set test_real_log_one (fn () :I
    (real/eq (real/log 1.0) 0.0)))
(ASSERT_TRUE (test_real_log_one) "real/log: log(1) should equal 0.0")

(set test_real_log_e (fn () :I
    (real/gt (real/log 2.718281828459045) 0.99)))
(ASSERT_TRUE (test_real_log_e) "real/log: log(e) should be approximately 1.0")

(set test_real_log_large (fn () :I
    (real/gt (real/log 10.0) 2.3)))
(ASSERT_TRUE (test_real_log_large) "real/log: log(10) should be greater than 2.3")

(set test_real_log_small (fn () :I
    (real/lt (real/log 0.5) 0.0)))
(ASSERT_TRUE (test_real_log_small) "real/log: log(0.5) should be negative")

(set test_real_log_zero_error (fn () :I
    (try
        (do
            (real/log 0.0)
            0)
        1)))
(ASSERT_TRUE (test_real_log_zero_error) "real/log: should error on zero input")

(set test_real_log_negative_error (fn () :I
    (try
        (do
            (real/log -1.0)
            0)
        1)))
(ASSERT_TRUE (test_real_log_negative_error) "real/log: should error on negative input")

(putln "real/log passed")

(set test_real_ceil_positive (fn () :I
    (int/eq (real/ceil 3.14) 4)))
(ASSERT_TRUE (test_real_ceil_positive) "real/ceil: ceil(3.14) should equal 4")

(set test_real_ceil_negative (fn () :I
    (int/eq (real/ceil -3.14) -3)))
(ASSERT_TRUE (test_real_ceil_negative) "real/ceil: ceil(-3.14) should equal -3")

(set test_real_ceil_exact (fn () :I
    (int/eq (real/ceil 5.0) 5)))
(ASSERT_TRUE (test_real_ceil_exact) "real/ceil: ceil(5.0) should equal 5")

(set test_real_ceil_zero (fn () :I
    (int/eq (real/ceil 0.0) 0)))
(ASSERT_TRUE (test_real_ceil_zero) "real/ceil: ceil(0.0) should equal 0")

(set test_real_ceil_small_positive (fn () :I
    (int/eq (real/ceil 0.001) 1)))
(ASSERT_TRUE (test_real_ceil_small_positive) "real/ceil: ceil(0.001) should equal 1")

(set test_real_ceil_small_negative (fn () :I
    (int/eq (real/ceil -0.001) 0)))
(ASSERT_TRUE (test_real_ceil_small_negative) "real/ceil: ceil(-0.001) should equal 0")

(putln "real/ceil passed")

(set test_real_round_up (fn () :I
    (int/eq (real/round 3.5) 4)))
(ASSERT_TRUE (test_real_round_up) "real/round: round(3.5) should equal 4")

(set test_real_round_down (fn () :I
    (int/eq (real/round 3.4) 3)))
(ASSERT_TRUE (test_real_round_down) "real/round: round(3.4) should equal 3")

(set test_real_round_negative_up (fn () :I
    (int/eq (real/round -3.5) -4)))
(ASSERT_TRUE (test_real_round_negative_up) "real/round: round(-3.5) should equal -4")

(set test_real_round_negative_down (fn () :I
    (int/eq (real/round -3.4) -3)))
(ASSERT_TRUE (test_real_round_negative_down) "real/round: round(-3.4) should equal -3")

(set test_real_round_exact (fn () :I
    (int/eq (real/round 5.0) 5)))
(ASSERT_TRUE (test_real_round_exact) "real/round: round(5.0) should equal 5")

(set test_real_round_zero (fn () :I
    (int/eq (real/round 0.0) 0)))
(ASSERT_TRUE (test_real_round_zero) "real/round: round(0.0) should equal 0")

(putln "real/round passed")

(set test_real_is_nan_normal (fn () :I
    (int/eq (real/is-nan 3.14) 0)))
(ASSERT_TRUE (test_real_is_nan_normal) "real/is-nan: normal number should return 0")

(set test_real_is_nan_zero (fn () :I
    (int/eq (real/is-nan 0.0) 0)))
(ASSERT_TRUE (test_real_is_nan_zero) "real/is-nan: zero should return 0")

(putln "real/is-nan passed")

(set test_real_is_inf_normal (fn () :I
    (int/eq (real/is-inf 3.14) 0)))
(ASSERT_TRUE (test_real_is_inf_normal) "real/is-inf: normal number should return 0")

(set test_real_is_inf_zero (fn () :I
    (int/eq (real/is-inf 0.0) 0)))
(ASSERT_TRUE (test_real_is_inf_zero) "real/is-inf: zero should return 0")

(set test_real_is_inf_large (fn () :I
    (int/eq (real/is-inf 999999999.0) 0)))
(ASSERT_TRUE (test_real_is_inf_large) "real/is-inf: large finite number should return 0")

(putln "real/is-inf passed")

(set test_real_is_finite_normal (fn () :I
    (int/eq (real/is-finite 3.14) 1)))
(ASSERT_TRUE (test_real_is_finite_normal) "real/is-finite: normal number should return 1")

(set test_real_is_finite_zero (fn () :I
    (int/eq (real/is-finite 0.0) 1)))
(ASSERT_TRUE (test_real_is_finite_zero) "real/is-finite: zero should return 1")

(set test_real_is_finite_negative (fn () :I
    (int/eq (real/is-finite -42.5) 1)))
(ASSERT_TRUE (test_real_is_finite_negative) "real/is-finite: negative number should return 1")

(set test_real_is_finite_large (fn () :I
    (int/eq (real/is-finite 999999999.0) 1)))
(ASSERT_TRUE (test_real_is_finite_large) "real/is-finite: large number should return 1")

(putln "real/is-finite passed")

(set test_int_abs_positive (fn () :I
    (int/eq (int/abs 42) 42)))
(ASSERT_TRUE (test_int_abs_positive) "int/abs: abs(42) should equal 42")

(set test_int_abs_negative (fn () :I
    (int/eq (int/abs -42) 42)))
(ASSERT_TRUE (test_int_abs_negative) "int/abs: abs(-42) should equal 42")

(set test_int_abs_zero (fn () :I
    (int/eq (int/abs 0) 0)))
(ASSERT_TRUE (test_int_abs_zero) "int/abs: abs(0) should equal 0")

(set test_int_abs_large_negative (fn () :I
    (int/eq (int/abs -999999) 999999)))
(ASSERT_TRUE (test_int_abs_large_negative) "int/abs: abs(-999999) should equal 999999")

(putln "int/abs passed")

(set test_real_abs_positive (fn () :I
    (real/eq (real/abs 3.14) 3.14)))
(ASSERT_TRUE (test_real_abs_positive) "real/abs: abs(3.14) should equal 3.14")

(set test_real_abs_negative (fn () :I
    (real/eq (real/abs -3.14) 3.14)))
(ASSERT_TRUE (test_real_abs_negative) "real/abs: abs(-3.14) should equal 3.14")

(set test_real_abs_zero (fn () :I
    (real/eq (real/abs 0.0) 0.0)))
(ASSERT_TRUE (test_real_abs_zero) "real/abs: abs(0.0) should equal 0.0")

(set test_real_abs_large_negative (fn () :I
    (real/eq (real/abs -999.999) 999.999)))
(ASSERT_TRUE (test_real_abs_large_negative) "real/abs: abs(-999.999) should equal 999.999")

(putln "real/abs passed")

(set test_sqrt_abs_chain (fn () :I
    (real/eq (real/sqrt (real/abs -16.0)) 4.0)))
(ASSERT_TRUE (test_sqrt_abs_chain) "chaining: sqrt(abs(-16)) should equal 4.0")

(set test_exp_log_inverse (fn () :I
    (real/gt (real/exp (real/log 10.0)) 9.99)))
(ASSERT_TRUE (test_exp_log_inverse) "chaining: exp(log(10)) should approximately equal 10")

(set test_round_sqrt (fn () :I
    (int/eq (real/round (real/sqrt 50.0)) 7)))
(ASSERT_TRUE (test_round_sqrt) "chaining: round(sqrt(50)) should equal 7")

(set test_abs_ceil_sub (fn () :I
    (int/eq (int/abs (int/sub (real/ceil 3.7) (real/round 8.5))) 5)))
(ASSERT_TRUE (test_abs_ceil_sub) "chaining: abs(ceil(3.7) - round(8.5)) should equal 5")

(putln "Advanced function chaining passed")

(set test_real_sqrt_wrong_type (fn () :I
    (try
        (do
            (real/sqrt 4)
            0)
        1)))
(ASSERT_TRUE (test_real_sqrt_wrong_type) "real/sqrt: should reject integer argument")

(set test_real_sqrt_string (fn () :I
    (try
        (do
            (real/sqrt "4.0")
            0)
        1)))
(ASSERT_TRUE (test_real_sqrt_string) "real/sqrt: should reject string argument")

(set test_real_exp_wrong_type (fn () :I
    (try
        (do
            (real/exp 1)
            0)
        1)))
(ASSERT_TRUE (test_real_exp_wrong_type) "real/exp: should reject integer argument")

(set test_real_log_wrong_type (fn () :I
    (try
        (do
            (real/log 10)
            0)
        1)))
(ASSERT_TRUE (test_real_log_wrong_type) "real/log: should reject integer argument")

(set test_real_ceil_wrong_type (fn () :I
    (try
        (do
            (real/ceil 3)
            0)
        1)))
(ASSERT_TRUE (test_real_ceil_wrong_type) "real/ceil: should reject integer argument")

(set test_real_round_wrong_type (fn () :I
    (try
        (do
            (real/round 3)
            0)
        1)))
(ASSERT_TRUE (test_real_round_wrong_type) "real/round: should reject integer argument")

(set test_real_is_nan_wrong_type (fn () :I
    (try
        (do
            (real/is-nan 3)
            0)
        1)))
(ASSERT_TRUE (test_real_is_nan_wrong_type) "real/is-nan: should reject integer argument")

(set test_real_is_inf_wrong_type (fn () :I
    (try
        (do
            (real/is-inf 3)
            0)
        1)))
(ASSERT_TRUE (test_real_is_inf_wrong_type) "real/is-inf: should reject integer argument")

(set test_real_is_finite_wrong_type (fn () :I
    (try
        (do
            (real/is-finite 3)
            0)
        1)))
(ASSERT_TRUE (test_real_is_finite_wrong_type) "real/is-finite: should reject integer argument")

(set test_int_abs_wrong_type (fn () :I
    (try
        (do
            (int/abs 42.0)
            0)
        1)))
(ASSERT_TRUE (test_int_abs_wrong_type) "int/abs: should reject real argument")

(set test_int_abs_string (fn () :I
    (try
        (do
            (int/abs "42")
            0)
        1)))
(ASSERT_TRUE (test_int_abs_string) "int/abs: should reject string argument")

(set test_real_abs_wrong_type (fn () :I
    (try
        (do
            (real/abs 42)
            0)
        1)))
(ASSERT_TRUE (test_real_abs_wrong_type) "real/abs: should reject integer argument")

(putln "Advanced function type errors passed")

(putln "")
(putln "=================================")
(putln "ALL NUMBERS TESTS PASSED")
(putln "=================================")
(putln "")
(putln "Test summary:")
(putln "  - Integer arithmetic (7 functions)")
(putln "  - Real arithmetic (6 functions)")
(putln "  - Type conversions (2 functions)")
(putln "  - Integer comparisons (5 functions)")
(putln "  - Real comparisons (5 functions)")
(putln "  - Random number generation (2 functions)")
(putln "  - Advanced math functions (5 functions)")
(putln "  - Real number inspection (3 functions)")
(putln "  - Absolute value (2 functions)")
(putln "  - Complex expressions and function chaining")
(putln "  - Type mismatch errors (50 cases)")
(putln "  - Division/modulo by zero errors")
(putln "  - Negative exponent errors")
(putln "  - Random bound validation errors")
(putln "  - Advanced math domain errors (sqrt, log, exp)")
(putln "  - Edge cases (zero, negative, boundaries)")
(putln "  - Precision and overflow cases")
(putln "")