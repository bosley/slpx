(use "bootstrap.slpx")

(putln "=== Filesystem Tests ===")

(set test_base "/tmp/slpx-fs-primitive-tests")

(try
    (do
        (if (fs/exists? test_base)
            (fs/rm_dir_all test_base)
            1))
    1)

(set test_exists_nonexistent (fn () :I
    (int/eq (fs/exists? "/tmp/definitely-does-not-exist-slpx-test-99999") 0)))
(ASSERT_TRUE (test_exists_nonexistent) "fs/exists?: nonexistent path should return 0")

(set test_mk_dir_basic (fn () :I
    (do
        (fs/mk_dir test_base)
        (fs/exists? test_base))))
(ASSERT_TRUE (test_mk_dir_basic) "fs/mk_dir: should create directory")

(set test_exists_dir (fn () :I
    (fs/exists? test_base)))
(ASSERT_TRUE (test_exists_dir) "fs/exists?: existing directory should return 1")

(set test_dir_check (fn () :I
    (fs/dir? test_base)))
(ASSERT_TRUE (test_dir_check) "fs/dir?: directory should return 1")

(set test_file_check_on_dir (fn () :I
    (int/eq (fs/file? test_base) 0)))
(ASSERT_TRUE (test_file_check_on_dir) "fs/file?: directory should return 0")

(putln "fs/exists?, fs/dir?, fs/file? basic checks passed")

(set test_file_path (str/concat test_base "/test.txt"))

(set test_write_file_basic (fn () :I
    (fs/write_file test_file_path "Hello, World!")))
(ASSERT_TRUE (test_write_file_basic) "fs/write_file: should return 1 on success")

(set test_file_exists (fn () :I
    (fs/exists? test_file_path)))
(ASSERT_TRUE (test_file_exists) "fs/exists?: created file should exist")

(set test_file_is_file (fn () :I
    (fs/file? test_file_path)))
(ASSERT_TRUE (test_file_is_file) "fs/file?: file should return 1")

(set test_file_not_dir (fn () :I
    (int/eq (fs/dir? test_file_path) 0)))
(ASSERT_TRUE (test_file_not_dir) "fs/dir?: file should return 0")

(putln "fs/write_file and type checking passed")

(set test_read_file_basic (fn () :I
    (set content (fs/read_file test_file_path))
    (str/eq content "Hello, World!")))
(ASSERT_TRUE (test_read_file_basic) "fs/read_file: should read written content")

(set test_read_file_empty (fn () :I
    (do
        (set empty_path (str/concat test_base "/empty.txt"))
        (fs/write_file empty_path "")
        (set content (fs/read_file empty_path))
        (str/eq content ""))))
(ASSERT_TRUE (test_read_file_empty) "fs/read_file: should handle empty files")

(putln "fs/read_file passed")

(set test_write_file_overwrite (fn () :I
    (do
        (fs/write_file test_file_path "New content")
        (set content (fs/read_file test_file_path))
        (str/eq content "New content"))))
(ASSERT_TRUE (test_write_file_overwrite) "fs/write_file: should overwrite existing file")

(set test_write_file_multiline (fn () :I
    (do
        (set ml_path (str/concat test_base "/multiline.txt"))
        (fs/write_file ml_path "Line 1\nLine 2\nLine 3")
        (set content (fs/read_file ml_path))
        (str/contains content "Line 2"))))
(ASSERT_TRUE (test_write_file_multiline) "fs/write_file: should handle multiline content")

(putln "fs/write_file overwrite and multiline passed")

(set test_append_file_basic (fn () :I
    (do
        (set append_path (str/concat test_base "/append.txt"))
        (fs/write_file append_path "First")
        (fs/append_file append_path " Second")
        (set content (fs/read_file append_path))
        (str/eq content "First Second"))))
(ASSERT_TRUE (test_append_file_basic) "fs/append_file: should append to existing file")

(set test_append_file_create (fn () :I
    (do
        (set new_append_path (str/concat test_base "/new_append.txt"))
        (fs/append_file new_append_path "Created by append")
        (set content (fs/read_file new_append_path))
        (str/eq content "Created by append"))))
(ASSERT_TRUE (test_append_file_create) "fs/append_file: should create file if not exists")

(set test_append_file_multiple (fn () :I
    (do
        (set multi_append (str/concat test_base "/multi_append.txt"))
        (fs/write_file multi_append "1")
        (fs/append_file multi_append "2")
        (fs/append_file multi_append "3")
        (set content (fs/read_file multi_append))
        (str/eq content "123"))))
(ASSERT_TRUE (test_append_file_multiple) "fs/append_file: multiple appends should work")

(putln "fs/append_file passed")

(set test_list_dir_basic (fn () :I
    (do
        (set files (fs/list_dir test_base))
        (if (reflect/list? files)
            (int/gt (list/len files) 0)
            0))))
(ASSERT_TRUE (test_list_dir_basic) "fs/list_dir: should return non-empty list")

(set test_list_dir_empty (fn () :I
    (do
        (set empty_dir (str/concat test_base "/empty_dir"))
        (fs/mk_dir empty_dir)
        (set files (fs/list_dir empty_dir))
        (int/eq (list/len files) 0))))
(ASSERT_TRUE (test_list_dir_empty) "fs/list_dir: empty directory should return empty list")

(set test_list_dir_content (fn () :I
    (do
        (set content_dir (str/concat test_base "/content_dir"))
        (fs/mk_dir content_dir)
        (fs/write_file (str/concat content_dir "/file1.txt") "1")
        (fs/write_file (str/concat content_dir "/file2.txt") "2")
        (set files (fs/list_dir content_dir))
        (int/eq (list/len files) 2))))
(ASSERT_TRUE (test_list_dir_content) "fs/list_dir: should list all files")

(putln "fs/list_dir passed")

(set test_mk_dir_all_nested (fn () :I
    (do
        (set nested (str/concat test_base "/a/b/c/d"))
        (fs/mk_dir_all nested)
        (fs/dir? nested))))
(ASSERT_TRUE (test_mk_dir_all_nested) "fs/mk_dir_all: should create nested directories")

(set test_mk_dir_all_existing (fn () :I
    (do
        (set existing (str/concat test_base "/existing"))
        (fs/mk_dir existing)
        (fs/mk_dir_all existing))))
(ASSERT_TRUE (test_mk_dir_all_existing) "fs/mk_dir_all: should handle existing directory")

(putln "fs/mk_dir and fs/mk_dir_all passed")

(set test_rm_file_basic (fn () :I
    (do
        (set del_path (str/concat test_base "/to_delete.txt"))
        (fs/write_file del_path "delete me")
        (fs/rm_file del_path)
        (int/eq (fs/exists? del_path) 0))))
(ASSERT_TRUE (test_rm_file_basic) "fs/rm_file: should remove file")

(set test_rm_file_multiple (fn () :I
    (do
        (set f1 (str/concat test_base "/del1.txt"))
        (set f2 (str/concat test_base "/del2.txt"))
        (fs/write_file f1 "1")
        (fs/write_file f2 "2")
        (fs/rm_file f1)
        (fs/rm_file f2)
        (if (int/eq (fs/exists? f1) 0)
            (int/eq (fs/exists? f2) 0)
            0))))
(ASSERT_TRUE (test_rm_file_multiple) "fs/rm_file: should remove multiple files")

(putln "fs/rm_file passed")

(set test_rm_dir_empty (fn () :I
    (do
        (set empty_rm (str/concat test_base "/empty_to_remove"))
        (fs/mk_dir empty_rm)
        (fs/rm_dir empty_rm)
        (int/eq (fs/exists? empty_rm) 0))))
(ASSERT_TRUE (test_rm_dir_empty) "fs/rm_dir: should remove empty directory")

(putln "fs/rm_dir passed")

(set test_rm_dir_all_with_content (fn () :I
    (do
        (set tree (str/concat test_base "/tree"))
        (fs/mk_dir_all (str/concat tree "/sub1/sub2"))
        (fs/write_file (str/concat tree "/file.txt") "data")
        (fs/write_file (str/concat tree "/sub1/file.txt") "data")
        (fs/rm_dir_all tree)
        (int/eq (fs/exists? tree) 0))))
(ASSERT_TRUE (test_rm_dir_all_with_content) "fs/rm_dir_all: should remove directory tree")

(set test_rm_dir_all_deep_nesting (fn () :I
    (do
        (set deep (str/concat test_base "/deep/a/b/c/d/e/f"))
        (fs/mk_dir_all deep)
        (fs/write_file (str/concat deep "/file.txt") "deep")
        (fs/rm_dir_all (str/concat test_base "/deep"))
        (int/eq (fs/exists? (str/concat test_base "/deep")) 0))))
(ASSERT_TRUE (test_rm_dir_all_deep_nesting) "fs/rm_dir_all: should remove deeply nested structures")

(putln "fs/rm_dir_all passed")

(set test_working_dir_returns_string (fn () :I
    (reflect/str? (fs/working_dir))))
(ASSERT_TRUE (test_working_dir_returns_string) "fs/working_dir: should return string")

(set test_working_dir_not_empty (fn () :I
    (int/gt (str/len (fs/working_dir)) 0)))
(ASSERT_TRUE (test_working_dir_not_empty) "fs/working_dir: should return non-empty path")

(putln "fs/working_dir passed")

(set test_set_working_dir_basic (fn () :I
    (do
        (set original (fs/working_dir))
        (fs/set_working_dir "/tmp")
        (set new_wd (fs/working_dir))
        (fs/set_working_dir original)
        (str/contains new_wd "tmp"))))
(ASSERT_TRUE (test_set_working_dir_basic) "fs/set_working_dir: should change working directory")

(set test_set_working_dir_affects_relative (fn () :I
    (do
        (set original (fs/working_dir))
        (fs/set_working_dir test_base)
        (fs/write_file "relative_test.txt" "relative")
        (set exists_relative (fs/exists? "relative_test.txt"))
        (fs/set_working_dir original)
        exists_relative)))
(ASSERT_TRUE (test_set_working_dir_affects_relative) "fs/set_working_dir: should affect relative paths")

(putln "fs/set_working_dir passed")

(set test_read_nonexistent_file (fn () :I
    (try
        (do
            (fs/read_file "/tmp/slpx-nonexistent-file-99999.txt")
            0)
        1)))
(ASSERT_TRUE (test_read_nonexistent_file) "fs/read_file: nonexistent file should error")

(set test_read_directory_as_file (fn () :I
    (try
        (do
            (fs/read_file test_base)
            0)
        1)))
(ASSERT_TRUE (test_read_directory_as_file) "fs/read_file: reading directory should error")

(putln "fs/read_file error cases passed")

(set test_write_to_readonly_location (fn () :I
    (try
        (do
            (fs/write_file "/this-should-not-work-99999.txt" "data")
            0)
        1)))
(ASSERT_TRUE (test_write_to_readonly_location) "fs/write_file: invalid location should error")

(putln "fs/write_file error cases passed")

(set test_mk_dir_existing (fn () :I
    (try
        (do
            (set dup_dir (str/concat test_base "/duplicate"))
            (fs/mk_dir dup_dir)
            (fs/mk_dir dup_dir)
            0)
        1)))
(ASSERT_TRUE (test_mk_dir_existing) "fs/mk_dir: creating existing directory should error")

(putln "fs/mk_dir error cases passed")

(set test_rm_file_nonexistent (fn () :I
    (try
        (do
            (fs/rm_file "/tmp/slpx-nonexistent-99999.txt")
            0)
        1)))
(ASSERT_TRUE (test_rm_file_nonexistent) "fs/rm_file: removing nonexistent file should error")

(set test_rm_file_directory (fn () :I
    (try
        (do
            (fs/rm_file test_base)
            0)
        1)))
(ASSERT_TRUE (test_rm_file_directory) "fs/rm_file: removing directory should error")

(putln "fs/rm_file error cases passed")

(set test_rm_dir_nonexistent (fn () :I
    (try
        (do
            (fs/rm_dir "/tmp/slpx-nonexistent-dir-99999")
            0)
        1)))
(ASSERT_TRUE (test_rm_dir_nonexistent) "fs/rm_dir: removing nonexistent directory should error")

(set test_rm_dir_nonempty (fn () :I
    (try
        (do
            (set nonempty (str/concat test_base "/nonempty"))
            (fs/mk_dir nonempty)
            (fs/write_file (str/concat nonempty "/file.txt") "data")
            (fs/rm_dir nonempty)
            0)
        1)))
(ASSERT_TRUE (test_rm_dir_nonempty) "fs/rm_dir: removing non-empty directory should error")

(putln "fs/rm_dir error cases passed")

(set test_list_dir_nonexistent (fn () :I
    (try
        (do
            (fs/list_dir "/tmp/slpx-nonexistent-dir-99999")
            0)
        1)))
(ASSERT_TRUE (test_list_dir_nonexistent) "fs/list_dir: listing nonexistent directory should error")

(set test_list_dir_file (fn () :I
    (try
        (do
            (fs/list_dir test_file_path)
            0)
        1)))
(ASSERT_TRUE (test_list_dir_file) "fs/list_dir: listing file should error")

(putln "fs/list_dir error cases passed")

(set test_set_working_dir_nonexistent (fn () :I
    (try
        (do
            (fs/set_working_dir "/tmp/slpx-nonexistent-99999")
            0)
        1)))
(ASSERT_TRUE (test_set_working_dir_nonexistent) "fs/set_working_dir: nonexistent directory should error")

(set test_set_working_dir_to_file (fn () :I
    (try
        (do
            (fs/set_working_dir test_file_path)
            0)
        1)))
(ASSERT_TRUE (test_set_working_dir_to_file) "fs/set_working_dir: setting to file should error")

(putln "fs/set_working_dir error cases passed")

(set test_exists_type_error (fn () :I
    (try
        (do
            (fs/exists? 42)
            0)
        1)))
(ASSERT_TRUE (test_exists_type_error) "fs/exists?: should reject non-string")

(set test_dir_type_error (fn () :I
    (try
        (do
            (fs/dir? 42)
            0)
        1)))
(ASSERT_TRUE (test_dir_type_error) "fs/dir?: should reject non-string")

(set test_file_type_error (fn () :I
    (try
        (do
            (fs/file? 42)
            0)
        1)))
(ASSERT_TRUE (test_file_type_error) "fs/file?: should reject non-string")

(set test_read_file_type_error (fn () :I
    (try
        (do
            (fs/read_file 42)
            0)
        1)))
(ASSERT_TRUE (test_read_file_type_error) "fs/read_file: should reject non-string path")

(set test_write_file_type_error_path (fn () :I
    (try
        (do
            (fs/write_file 42 "data")
            0)
        1)))
(ASSERT_TRUE (test_write_file_type_error_path) "fs/write_file: should reject non-string path")

(set test_write_file_type_error_data (fn () :I
    (try
        (do
            (fs/write_file "/tmp/test.txt" 42)
            0)
        1)))
(ASSERT_TRUE (test_write_file_type_error_data) "fs/write_file: should reject non-string data")

(set test_append_file_type_error_path (fn () :I
    (try
        (do
            (fs/append_file 42 "data")
            0)
        1)))
(ASSERT_TRUE (test_append_file_type_error_path) "fs/append_file: should reject non-string path")

(set test_append_file_type_error_data (fn () :I
    (try
        (do
            (fs/append_file "/tmp/test.txt" 42)
            0)
        1)))
(ASSERT_TRUE (test_append_file_type_error_data) "fs/append_file: should reject non-string data")

(set test_rm_file_type_error (fn () :I
    (try
        (do
            (fs/rm_file 42)
            0)
        1)))
(ASSERT_TRUE (test_rm_file_type_error) "fs/rm_file: should reject non-string")

(set test_rm_dir_type_error (fn () :I
    (try
        (do
            (fs/rm_dir 42)
            0)
        1)))
(ASSERT_TRUE (test_rm_dir_type_error) "fs/rm_dir: should reject non-string")

(set test_rm_dir_all_type_error (fn () :I
    (try
        (do
            (fs/rm_dir_all 42)
            0)
        1)))
(ASSERT_TRUE (test_rm_dir_all_type_error) "fs/rm_dir_all: should reject non-string")

(set test_mk_dir_type_error (fn () :I
    (try
        (do
            (fs/mk_dir 42)
            0)
        1)))
(ASSERT_TRUE (test_mk_dir_type_error) "fs/mk_dir: should reject non-string")

(set test_mk_dir_all_type_error (fn () :I
    (try
        (do
            (fs/mk_dir_all 42)
            0)
        1)))
(ASSERT_TRUE (test_mk_dir_all_type_error) "fs/mk_dir_all: should reject non-string")

(set test_list_dir_type_error (fn () :I
    (try
        (do
            (fs/list_dir 42)
            0)
        1)))
(ASSERT_TRUE (test_list_dir_type_error) "fs/list_dir: should reject non-string")

(set test_set_working_dir_type_error (fn () :I
    (try
        (do
            (fs/set_working_dir 42)
            0)
        1)))
(ASSERT_TRUE (test_set_working_dir_type_error) "fs/set_working_dir: should reject non-string")

(putln "Type checking tests passed")

(set test_complex_workflow (fn () :I
    (do
        (set workflow_dir (str/concat test_base "/workflow"))
        (fs/mk_dir_all (str/concat workflow_dir "/data"))
        (fs/write_file (str/concat workflow_dir "/data/input.txt") "input data")
        (set content (fs/read_file (str/concat workflow_dir "/data/input.txt")))
        (set processed (str/concat content " processed"))
        (fs/write_file (str/concat workflow_dir "/data/output.txt") processed)
        (set files (fs/list_dir (str/concat workflow_dir "/data")))
        (if (int/eq (list/len files) 2)
            (do
                (fs/rm_dir_all workflow_dir)
                (int/eq (fs/exists? workflow_dir) 0))
            0))))
(ASSERT_TRUE (test_complex_workflow) "complex: full workflow should work")

(set test_binary_data_simulation (fn () :I
    (do
        (set binary_path (str/concat test_base "/binary.dat"))
        (set data "Binary-like\x00data\nwith\tspecial\rchars")
        (fs/write_file binary_path data)
        (set read_back (fs/read_file binary_path))
        (str/eq data read_back))))
(ASSERT_TRUE (test_binary_data_simulation) "complex: special characters should survive round-trip")

(set test_large_file (fn () :I
    (do
        (set large_path (str/concat test_base "/large.txt"))
        (set chunk "0123456789")
        (fs/write_file large_path chunk)
        (set i 0)
        (set result 1)
        (list/iter (list/new 99 0) (fn (el :*) :I
            (do
                (fs/append_file large_path chunk)
                1)))
        (set content (fs/read_file large_path))
        (int/eq (str/len content) 1000))))
(ASSERT_TRUE (test_large_file) "complex: large file operations should work")

(putln "Complex operations passed")

(try
    (fs/rm_dir_all test_base)
    1)

(putln "Cleanup completed")

(putln "")
(putln "=================================")
(putln "ALL FILESYSTEM TESTS PASSED")
(putln "=================================")
(putln "")
(putln "Test summary:")
(putln "  - fs/exists? (3 positive + 1 negative)")
(putln "  - fs/dir? (1 positive + 1 negative + 1 type)")
(putln "  - fs/file? (1 positive + 1 negative + 1 type)")
(putln "  - fs/read_file (2 positive + 3 negative + 1 type)")
(putln "  - fs/write_file (3 positive + 2 negative + 2 type)")
(putln "  - fs/append_file (3 positive + 2 type)")
(putln "  - fs/rm_file (2 positive + 3 negative + 1 type)")
(putln "  - fs/rm_dir (1 positive + 3 negative + 1 type)")
(putln "  - fs/rm_dir_all (2 positive + 1 type)")
(putln "  - fs/mk_dir (1 positive + 2 negative + 1 type)")
(putln "  - fs/mk_dir_all (2 positive + 1 type)")
(putln "  - fs/list_dir (3 positive + 3 negative + 1 type)")
(putln "  - fs/working_dir (2 positive)")
(putln "  - fs/set_working_dir (2 positive + 3 negative + 1 type)")
(putln "  - Complex operations (3 tests)")
(putln "")
(putln "Total: 31 positive + 20 negative + 15 type = 66 test assertions")
(putln "")
